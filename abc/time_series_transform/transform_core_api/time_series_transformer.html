<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>time_series_transform.transform_core_api.time_series_transformer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>time_series_transform.transform_core_api.time_series_transformer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import gc
import uuid
import numpy as np
import pandas as pd
import pyarrow as pa
import tensorflow as tf
from pyarrow import parquet as pq
from collections import defaultdict
from time_series_transform.transform_core_api.base import *



class Pandas_Time_Series_Tensor_Dataset(object):
    def __init__(self, pandasFrame, config={}):
        &#34;&#34;&#34;
        Pandas_Time_Series_Tensor_Dataset prepared pandas data into sequence data type
        
        This class will follow the configuration to transform the pandas dataframe into sequence data
        the restriction for using this interface:
            - the column of data frame has to be [dim1, dim2,dim....., t0,t1,t2,t....], and the index has to be the item or id
            - the configuration data has to be a dictionary and follow by this template
            {
                &#34;colName&#34;: str,
                &#34;tensorType&#34;:{&#39;sequence&#39;,&#39;label&#39;,&#39;category&#39;},
                &#34;param&#34;: {&#34;windowSize&#34;:int,&#34;seqSize&#34;:int,&#34;outType&#34;:numpy datatype}
                &#34;sequence_stack&#34;: other colName [option]
                &#34;responseVariable&#34;: {True,False} [optional]
            }

        Parameters
        ----------
        pandasFrame : pandas DataFrame
            input data
        config : dict, optional
            the configuration to trainsform pandas dataFrame, by default {}
        &#34;&#34;&#34;
        super().__init__()
        self.df = pandasFrame
        self.config = config


    def set_config(self, name, colNames, tensorType, sequence_stack, isResponseVar, windowSize, seqSize, outType):
        &#34;&#34;&#34;
        set_config the setter of config
        
        this setter provide an quick entry point to setup configuration
        
        Parameters
        ----------
        name : str
            the name of the output sequence or output column
        colNames : list of string
            the name of pandas frame used for transformation
        tensorType : {&#39;sequence&#39;,&#39;label&#39;,&#39;category&#39;}
            provide different type of transformation
        sequence_stack : string of name for stacking
            the target name for stacking
        isResponseVar : bool
            whether the data is response variable or predictor
        windowSize: int
            sequence grouping size
        seqSize: int
            total length of sequence
        outType: numpy data type
            output data type
        &#34;&#34;&#34;
        self.config[name] = {
            &#39;colNames&#39;: colNames,
            &#39;tensorType&#39;: tensorType,
            &#39;param&#39;: {
                &#34;windowSize&#34;: windowSize, 
                &#34;seqSize&#34;: seqSize, 
                &#34;outType&#34;: outType
                },
            &#39;sequence_stack&#39;: sequence_stack,
            &#39;responseVariable&#39;: isResponseVar
        }

    def _dict_keys_values(self, data, keys):
        res = []
        for k in keys:
            res.append(data[k])
        return np.array(res)

    def _make_time_series_dataset(self, data):
        tensorDict = {}
        for i in self.config:
            process_data = self._dict_keys_values(
                data, self.config[i][&#39;colNames&#39;])
            tsf = Time_Series_Tensor_Factory(
                process_data,
                self.config[i][&#39;tensorType&#39;]
            )
            tensor = tsf.get_time_series_tensor(
                name=i,
                **self.config[i][&#39;param&#39;]
            )
            if self.config[i].get(&#39;sequence_stack&#39;) is not None:
                sequence_stack = self.config[i].get(&#39;sequence_stack&#39;)
                tensorDict[sequence_stack].stack_time_series_tensors(tensor)
            else:
                tensorDict[i] = tensor
        tensorList = [v for v in tensorDict.values()]
        return Time_Series_Dataset(tensorList).make_dataset()

    def make_data_generator(self):
        &#34;&#34;&#34;
        make_data_generator prepare an generator to output the transformed data
        
        
        Yields
        -------
        tuple
            it will output X data and Y data
        &#34;&#34;&#34;
        data = self.df.to_dict(&#39;records&#39;)
        for i in data:
            res = self._make_time_series_dataset(i)
            Xtensor = {}
            Ytensor = None
            for c in self.config:
                if self.config[c].get(&#34;sequence_stack&#34;) is not None:
                    continue
                if self.config[c].get(&#34;responseVariable&#34;):
                    Ytensor = res[&#39;data&#39;][c]
                else:
                    Xtensor[c] = res[&#39;data&#39;][c]
            yield (Xtensor, Ytensor)


    def expand_dataFrame_by_date(self, categoryCol,timeSeriesCol,newIX=True,byCategory=True,dropna=False):
        &#34;&#34;&#34;
        expand_dataFrame_by_date A help function to prepare dataFrame for tensor transformation
        
        It will change the original dataFrame of
        byCategory is set to be True [x1,x2,x3,time series,category] -&gt; [x1_t1,x1_t2...x3_t|index-&gt;category]
        byCategory is set to be False [x1,x2,x3,time series,category] -&gt; [category_x1_t1,category_x1_t2...category_x3_t]
        
        Note: 
        x is column name 
        t represent time series column i.e. Date --&gt; YYYY-MM-DD format is recommended
        
        Parameters
        ----------
        categoryCol : str
            column name of category
        timeSeriesCol : str
            column name of time series
        newIX : bool, optional
            if True, time series column will be converted into 1,2,3,....len(timeSeriesCol), by default True
        byCategory : bool, optional
            if True, the dataFrame will create new row instead of different column for categories, by default True
        dropna : bool, optional
            if True, nan column will be dropped, by default False
        
        Returns
        -------
        iterable
            the index of time series columns
        &#34;&#34;&#34;
        if newIX:
            self.df = self.df.sort_values(timeSeriesCol,ascending = True)
            ixDict = dict(zip(self.df[timeSeriesCol].unique(),list(range(1,len(self.df[timeSeriesCol].unique())+1))))
            self.df[timeSeriesCol] = self.df[timeSeriesCol].apply(lambda x: ixDict[x])
        else:
            ixDict = self.df[timeSeriesCol].values

        if byCategory:
            self.df = self._pivot_df(self.df,categoryCol,timeSeriesCol,dropna)
        else:
            self.df = self._flatten_df(self.df,categoryCol,timeSeriesCol,dropna)
        return ixDict

    def _pivot_df(self,df,categoryCol,timeSeriesCol,dropna):
        df = df.pivot(categoryCol,timeSeriesCol,df.columns.drop([categoryCol,timeSeriesCol]))
        df.columns = list(map(lambda x: f&#34;{x[0]}_{x[1]}&#34;,df.columns))
        if dropna:
            df = df.dropna(axis =1)
        return df

    def _flatten_df(self,df,categoryCol,timeSeriesCol,dropna):
        categoryList = df[categoryCol].unique()
        resDf = None
        for i in categoryList:
            subDf = df[df[categoryCol]==i]
            subDf = self._pivot_df(subDf,categoryCol,timeSeriesCol,dropna)
            subDf.columns = list(map(lambda x: f&#34;{i}_{x}&#34;,subDf.columns))
            subDf = subDf.reset_index(drop=True)
            if resDf is None:
                resDf = subDf
            else:
                resDf = pd.concat([resDf,subDf],axis =1)
        return resDf


    def transform_dataFrame(self,colName,targetCol,timeSeriesCol,transformFunc,*args,**kwargs):
        &#34;&#34;&#34;
        transform_dataFrame this function use apply method to transfrom dataFrame
        
        Parameters
        ----------
        colName : str
            target column for transformation
        targetCol : str
            the column to store new data
        timeSeriesCol : str
            time series column for sorting before apply function
        transformFunc : func
            the function implmented in the apply function
        axis : int, optional
            0 for row 1 for column, by default 1

        &#34;&#34;&#34;
        self.df = self.df.sort_values(timeSeriesCol,ascending = True)
        self.df[targetCol] = transformFunc(self.df[colName].values,*args,**kwargs)
        return self


    def __repr__(self):
        return f&#34;Tensor Transformer Config: {repr(self.config)}&#34;



class Pandas_Time_Series_Panel_Dataset(object):

    def __init__(self,pandasFrame):
        &#34;&#34;&#34;
        Pandas_Time_Series_Panel_Dataset prepares the dataset for traditional machine learning problem.
        
        It can convert the pandas Frame into multiple lagging features or create a lead feature as label.
        
        Parameters
        ----------
        pandasFrame : pandas dataFrame
            the dataFrame for preprocessing
        &#34;&#34;&#34;
        self.df = pandasFrame

    def expand_dataFrame_by_category(self,indexCol,keyCol):
        &#34;&#34;&#34;
        expand_dataFrame_by_category to create columns for different categories
        
        it convert the dataFrame from [x1,x2,x3,...,category] -&gt; [category_x1,category_x2,category_x3,....]
        
        Parameters
        ----------
        indexCol : str
            the time series column
        keyCol : str
            the category column
        
        &#34;&#34;&#34;
        keys = self.df[keyCol].unique()
        tmpDf = None
        for ix,k in enumerate(keys):
            if ix == 0:
                tmpDf = self.df[self.df[keyCol]==k]
                tmpDf = tmpDf.set_index(indexCol)
                tmpDf = tmpDf.drop(keyCol,axis=1)
                tmpDf.columns = list(map(lambda x: f&#39;{x}_{k}&#39;,tmpDf.columns))
            else:
                df2 = self.df[self.df[keyCol]==k]
                df2 = df2.drop(keyCol,axis=1).set_index(indexCol)
                df2.columns = list(map(lambda x: f&#39;{x}_{k}&#39;,df2.columns))
                tmpDf = tmpDf.join(df2,how=&#39;outer&#39;)
        self.df = pd.DataFrame(tmpDf.to_records())
        return self


    def make_slide_window(self,indexCol,windowSize,colList=None,groupby=None):
        &#34;&#34;&#34;
        make_slide_window make lag features given with the range of window size
        
        this function will create lag features along with the given window size.
        if colList set to be None, all column will be used to create lag features.
        groupby is for category columns. This paramemter for dataFrame which did not
        expand by categories.
        
        Parameters
        ----------
        indexCol : str
            time series column
        windowSize : int
            lag number created
        colList : list, optional
            the columns used to create lag features, by default None
        groupby : str, optional
            category column, by default None

        &#34;&#34;&#34;
        if colList is None:
            self.df = self.df.sort_values(indexCol,ascending = True)
            colList = self.df.columns.drop(indexCol).tolist()
        for col in colList:
            for i in range(1,windowSize+1):
                if groupby is None:
                    self.df[f&#39;{col}_lag{str(i)}&#39;] = self.df[col].shift(i)
                else:
                    if col == groupby:
                        continue
                    self.df[f&#39;{col}_lag{str(i)}&#39;] = self.df.groupby(groupby)[col].shift(i)
        return self


    def make_lead_column(self,indexCol,baseCol,leadNum,groupby=None):
        &#34;&#34;&#34;
        make_lead_column this function will create lead feature along with the lead number
        
        this function is for creating label for supervised learning
        groupby is for category columns. This paramemter for dataFrame which did not
        expand by categories.

        Parameters
        ----------
        indexCol : str
            time series column
        baseCol : str
            the column for lead feature
        leadNum : int
            the lead time unit
        groupby : str, optional
            category column, by default None
        
        Returns
        -------
        [type]
            [description]
        &#34;&#34;&#34;
        self.df = self.df.sort_values(indexCol,ascending = False)
        if groupby is None:
            self.df[f&#39;{baseCol}_lead{str(leadNum)}&#39;] = self.df[baseCol].shift(leadNum)
        else:
            self.df[f&#39;{baseCol}_lead{str(leadNum)}&#39;] = self.df.groupby(groupby)[baseCol].shift(leadNum)            
        return self

    def transform_dataFrame(self,colName,targetCol,timeSeriesCol,transformFunc,*args,**kwargs):
        &#34;&#34;&#34;
        transform_dataFrame this function use apply method to transfrom dataFrame
        
        Parameters
        ----------
        colName : str
            target column for transformation
        targetCol : str
            the column to store new data
        timeSeriesCol : str
            time series column for sorting before apply function
        transformFunc : func
            the function implmented in the apply function
        axis : int, optional
            0 for row 1 for column, by default 1

        &#34;&#34;&#34;
        self.df = self.df.sort_values(timeSeriesCol,ascending = True)
        self.df[targetCol] = transformFunc(self.df[colName].values,*args,**kwargs)
        return self

    def __repr__(self):
        return repr(self.df)
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset"><code class="flex name class">
<span>class <span class="ident">Pandas_Time_Series_Panel_Dataset</span></span>
<span>(</span><span>pandasFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>Pandas_Time_Series_Panel_Dataset prepares the dataset for traditional machine learning problem.</p>
<p>It can convert the pandas Frame into multiple lagging features or create a lead feature as label.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pandasFrame</code></strong> :&ensp;<code>pandas dataFrame</code></dt>
<dd>the dataFrame for preprocessing</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pandas_Time_Series_Panel_Dataset(object):

    def __init__(self,pandasFrame):
        &#34;&#34;&#34;
        Pandas_Time_Series_Panel_Dataset prepares the dataset for traditional machine learning problem.
        
        It can convert the pandas Frame into multiple lagging features or create a lead feature as label.
        
        Parameters
        ----------
        pandasFrame : pandas dataFrame
            the dataFrame for preprocessing
        &#34;&#34;&#34;
        self.df = pandasFrame

    def expand_dataFrame_by_category(self,indexCol,keyCol):
        &#34;&#34;&#34;
        expand_dataFrame_by_category to create columns for different categories
        
        it convert the dataFrame from [x1,x2,x3,...,category] -&gt; [category_x1,category_x2,category_x3,....]
        
        Parameters
        ----------
        indexCol : str
            the time series column
        keyCol : str
            the category column
        
        &#34;&#34;&#34;
        keys = self.df[keyCol].unique()
        tmpDf = None
        for ix,k in enumerate(keys):
            if ix == 0:
                tmpDf = self.df[self.df[keyCol]==k]
                tmpDf = tmpDf.set_index(indexCol)
                tmpDf = tmpDf.drop(keyCol,axis=1)
                tmpDf.columns = list(map(lambda x: f&#39;{x}_{k}&#39;,tmpDf.columns))
            else:
                df2 = self.df[self.df[keyCol]==k]
                df2 = df2.drop(keyCol,axis=1).set_index(indexCol)
                df2.columns = list(map(lambda x: f&#39;{x}_{k}&#39;,df2.columns))
                tmpDf = tmpDf.join(df2,how=&#39;outer&#39;)
        self.df = pd.DataFrame(tmpDf.to_records())
        return self


    def make_slide_window(self,indexCol,windowSize,colList=None,groupby=None):
        &#34;&#34;&#34;
        make_slide_window make lag features given with the range of window size
        
        this function will create lag features along with the given window size.
        if colList set to be None, all column will be used to create lag features.
        groupby is for category columns. This paramemter for dataFrame which did not
        expand by categories.
        
        Parameters
        ----------
        indexCol : str
            time series column
        windowSize : int
            lag number created
        colList : list, optional
            the columns used to create lag features, by default None
        groupby : str, optional
            category column, by default None

        &#34;&#34;&#34;
        if colList is None:
            self.df = self.df.sort_values(indexCol,ascending = True)
            colList = self.df.columns.drop(indexCol).tolist()
        for col in colList:
            for i in range(1,windowSize+1):
                if groupby is None:
                    self.df[f&#39;{col}_lag{str(i)}&#39;] = self.df[col].shift(i)
                else:
                    if col == groupby:
                        continue
                    self.df[f&#39;{col}_lag{str(i)}&#39;] = self.df.groupby(groupby)[col].shift(i)
        return self


    def make_lead_column(self,indexCol,baseCol,leadNum,groupby=None):
        &#34;&#34;&#34;
        make_lead_column this function will create lead feature along with the lead number
        
        this function is for creating label for supervised learning
        groupby is for category columns. This paramemter for dataFrame which did not
        expand by categories.

        Parameters
        ----------
        indexCol : str
            time series column
        baseCol : str
            the column for lead feature
        leadNum : int
            the lead time unit
        groupby : str, optional
            category column, by default None
        
        Returns
        -------
        [type]
            [description]
        &#34;&#34;&#34;
        self.df = self.df.sort_values(indexCol,ascending = False)
        if groupby is None:
            self.df[f&#39;{baseCol}_lead{str(leadNum)}&#39;] = self.df[baseCol].shift(leadNum)
        else:
            self.df[f&#39;{baseCol}_lead{str(leadNum)}&#39;] = self.df.groupby(groupby)[baseCol].shift(leadNum)            
        return self

    def transform_dataFrame(self,colName,targetCol,timeSeriesCol,transformFunc,*args,**kwargs):
        &#34;&#34;&#34;
        transform_dataFrame this function use apply method to transfrom dataFrame
        
        Parameters
        ----------
        colName : str
            target column for transformation
        targetCol : str
            the column to store new data
        timeSeriesCol : str
            time series column for sorting before apply function
        transformFunc : func
            the function implmented in the apply function
        axis : int, optional
            0 for row 1 for column, by default 1

        &#34;&#34;&#34;
        self.df = self.df.sort_values(timeSeriesCol,ascending = True)
        self.df[targetCol] = transformFunc(self.df[colName].values,*args,**kwargs)
        return self

    def __repr__(self):
        return repr(self.df)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset.expand_dataFrame_by_category"><code class="name flex">
<span>def <span class="ident">expand_dataFrame_by_category</span></span>(<span>self, indexCol, keyCol)</span>
</code></dt>
<dd>
<div class="desc"><p>expand_dataFrame_by_category to create columns for different categories</p>
<p>it convert the dataFrame from [x1,x2,x3,&hellip;,category] -&gt; [category_x1,category_x2,category_x3,....]</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>indexCol</code></strong> :&ensp;<code>str</code></dt>
<dd>the time series column</dd>
<dt><strong><code>keyCol</code></strong> :&ensp;<code>str</code></dt>
<dd>the category column</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand_dataFrame_by_category(self,indexCol,keyCol):
    &#34;&#34;&#34;
    expand_dataFrame_by_category to create columns for different categories
    
    it convert the dataFrame from [x1,x2,x3,...,category] -&gt; [category_x1,category_x2,category_x3,....]
    
    Parameters
    ----------
    indexCol : str
        the time series column
    keyCol : str
        the category column
    
    &#34;&#34;&#34;
    keys = self.df[keyCol].unique()
    tmpDf = None
    for ix,k in enumerate(keys):
        if ix == 0:
            tmpDf = self.df[self.df[keyCol]==k]
            tmpDf = tmpDf.set_index(indexCol)
            tmpDf = tmpDf.drop(keyCol,axis=1)
            tmpDf.columns = list(map(lambda x: f&#39;{x}_{k}&#39;,tmpDf.columns))
        else:
            df2 = self.df[self.df[keyCol]==k]
            df2 = df2.drop(keyCol,axis=1).set_index(indexCol)
            df2.columns = list(map(lambda x: f&#39;{x}_{k}&#39;,df2.columns))
            tmpDf = tmpDf.join(df2,how=&#39;outer&#39;)
    self.df = pd.DataFrame(tmpDf.to_records())
    return self</code></pre>
</details>
</dd>
<dt id="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset.make_lead_column"><code class="name flex">
<span>def <span class="ident">make_lead_column</span></span>(<span>self, indexCol, baseCol, leadNum, groupby=None)</span>
</code></dt>
<dd>
<div class="desc"><p>make_lead_column this function will create lead feature along with the lead number</p>
<p>this function is for creating label for supervised learning
groupby is for category columns. This paramemter for dataFrame which did not
expand by categories.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>indexCol</code></strong> :&ensp;<code>str</code></dt>
<dd>time series column</dd>
<dt><strong><code>baseCol</code></strong> :&ensp;<code>str</code></dt>
<dd>the column for lead feature</dd>
<dt><strong><code>leadNum</code></strong> :&ensp;<code>int</code></dt>
<dd>the lead time unit</dd>
<dt><strong><code>groupby</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>category column, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[type]
[description]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_lead_column(self,indexCol,baseCol,leadNum,groupby=None):
    &#34;&#34;&#34;
    make_lead_column this function will create lead feature along with the lead number
    
    this function is for creating label for supervised learning
    groupby is for category columns. This paramemter for dataFrame which did not
    expand by categories.

    Parameters
    ----------
    indexCol : str
        time series column
    baseCol : str
        the column for lead feature
    leadNum : int
        the lead time unit
    groupby : str, optional
        category column, by default None
    
    Returns
    -------
    [type]
        [description]
    &#34;&#34;&#34;
    self.df = self.df.sort_values(indexCol,ascending = False)
    if groupby is None:
        self.df[f&#39;{baseCol}_lead{str(leadNum)}&#39;] = self.df[baseCol].shift(leadNum)
    else:
        self.df[f&#39;{baseCol}_lead{str(leadNum)}&#39;] = self.df.groupby(groupby)[baseCol].shift(leadNum)            
    return self</code></pre>
</details>
</dd>
<dt id="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset.make_slide_window"><code class="name flex">
<span>def <span class="ident">make_slide_window</span></span>(<span>self, indexCol, windowSize, colList=None, groupby=None)</span>
</code></dt>
<dd>
<div class="desc"><p>make_slide_window make lag features given with the range of window size</p>
<p>this function will create lag features along with the given window size.
if colList set to be None, all column will be used to create lag features.
groupby is for category columns. This paramemter for dataFrame which did not
expand by categories.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>indexCol</code></strong> :&ensp;<code>str</code></dt>
<dd>time series column</dd>
<dt><strong><code>windowSize</code></strong> :&ensp;<code>int</code></dt>
<dd>lag number created</dd>
<dt><strong><code>colList</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>the columns used to create lag features, by default None</dd>
<dt><strong><code>groupby</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>category column, by default None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_slide_window(self,indexCol,windowSize,colList=None,groupby=None):
    &#34;&#34;&#34;
    make_slide_window make lag features given with the range of window size
    
    this function will create lag features along with the given window size.
    if colList set to be None, all column will be used to create lag features.
    groupby is for category columns. This paramemter for dataFrame which did not
    expand by categories.
    
    Parameters
    ----------
    indexCol : str
        time series column
    windowSize : int
        lag number created
    colList : list, optional
        the columns used to create lag features, by default None
    groupby : str, optional
        category column, by default None

    &#34;&#34;&#34;
    if colList is None:
        self.df = self.df.sort_values(indexCol,ascending = True)
        colList = self.df.columns.drop(indexCol).tolist()
    for col in colList:
        for i in range(1,windowSize+1):
            if groupby is None:
                self.df[f&#39;{col}_lag{str(i)}&#39;] = self.df[col].shift(i)
            else:
                if col == groupby:
                    continue
                self.df[f&#39;{col}_lag{str(i)}&#39;] = self.df.groupby(groupby)[col].shift(i)
    return self</code></pre>
</details>
</dd>
<dt id="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset.transform_dataFrame"><code class="name flex">
<span>def <span class="ident">transform_dataFrame</span></span>(<span>self, colName, targetCol, timeSeriesCol, transformFunc, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>transform_dataFrame this function use apply method to transfrom dataFrame</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>colName</code></strong> :&ensp;<code>str</code></dt>
<dd>target column for transformation</dd>
<dt><strong><code>targetCol</code></strong> :&ensp;<code>str</code></dt>
<dd>the column to store new data</dd>
<dt><strong><code>timeSeriesCol</code></strong> :&ensp;<code>str</code></dt>
<dd>time series column for sorting before apply function</dd>
<dt><strong><code>transformFunc</code></strong> :&ensp;<code>func</code></dt>
<dd>the function implmented in the apply function</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>0 for row 1 for column, by default 1</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_dataFrame(self,colName,targetCol,timeSeriesCol,transformFunc,*args,**kwargs):
    &#34;&#34;&#34;
    transform_dataFrame this function use apply method to transfrom dataFrame
    
    Parameters
    ----------
    colName : str
        target column for transformation
    targetCol : str
        the column to store new data
    timeSeriesCol : str
        time series column for sorting before apply function
    transformFunc : func
        the function implmented in the apply function
    axis : int, optional
        0 for row 1 for column, by default 1

    &#34;&#34;&#34;
    self.df = self.df.sort_values(timeSeriesCol,ascending = True)
    self.df[targetCol] = transformFunc(self.df[colName].values,*args,**kwargs)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset"><code class="flex name class">
<span>class <span class="ident">Pandas_Time_Series_Tensor_Dataset</span></span>
<span>(</span><span>pandasFrame, config={})</span>
</code></dt>
<dd>
<div class="desc"><p>Pandas_Time_Series_Tensor_Dataset prepared pandas data into sequence data type</p>
<p>This class will follow the configuration to transform the pandas dataframe into sequence data
the restriction for using this interface:
- the column of data frame has to be [dim1, dim2,dim....., t0,t1,t2,t....], and the index has to be the item or id
- the configuration data has to be a dictionary and follow by this template
{
"colName": str,
"tensorType":{'sequence','label','category'},
"param": {"windowSize":int,"seqSize":int,"outType":numpy datatype}
"sequence_stack": other colName [option]
"responseVariable": {True,False} [optional]
}</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pandasFrame</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>input data</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>the configuration to trainsform pandas dataFrame, by default {}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pandas_Time_Series_Tensor_Dataset(object):
    def __init__(self, pandasFrame, config={}):
        &#34;&#34;&#34;
        Pandas_Time_Series_Tensor_Dataset prepared pandas data into sequence data type
        
        This class will follow the configuration to transform the pandas dataframe into sequence data
        the restriction for using this interface:
            - the column of data frame has to be [dim1, dim2,dim....., t0,t1,t2,t....], and the index has to be the item or id
            - the configuration data has to be a dictionary and follow by this template
            {
                &#34;colName&#34;: str,
                &#34;tensorType&#34;:{&#39;sequence&#39;,&#39;label&#39;,&#39;category&#39;},
                &#34;param&#34;: {&#34;windowSize&#34;:int,&#34;seqSize&#34;:int,&#34;outType&#34;:numpy datatype}
                &#34;sequence_stack&#34;: other colName [option]
                &#34;responseVariable&#34;: {True,False} [optional]
            }

        Parameters
        ----------
        pandasFrame : pandas DataFrame
            input data
        config : dict, optional
            the configuration to trainsform pandas dataFrame, by default {}
        &#34;&#34;&#34;
        super().__init__()
        self.df = pandasFrame
        self.config = config


    def set_config(self, name, colNames, tensorType, sequence_stack, isResponseVar, windowSize, seqSize, outType):
        &#34;&#34;&#34;
        set_config the setter of config
        
        this setter provide an quick entry point to setup configuration
        
        Parameters
        ----------
        name : str
            the name of the output sequence or output column
        colNames : list of string
            the name of pandas frame used for transformation
        tensorType : {&#39;sequence&#39;,&#39;label&#39;,&#39;category&#39;}
            provide different type of transformation
        sequence_stack : string of name for stacking
            the target name for stacking
        isResponseVar : bool
            whether the data is response variable or predictor
        windowSize: int
            sequence grouping size
        seqSize: int
            total length of sequence
        outType: numpy data type
            output data type
        &#34;&#34;&#34;
        self.config[name] = {
            &#39;colNames&#39;: colNames,
            &#39;tensorType&#39;: tensorType,
            &#39;param&#39;: {
                &#34;windowSize&#34;: windowSize, 
                &#34;seqSize&#34;: seqSize, 
                &#34;outType&#34;: outType
                },
            &#39;sequence_stack&#39;: sequence_stack,
            &#39;responseVariable&#39;: isResponseVar
        }

    def _dict_keys_values(self, data, keys):
        res = []
        for k in keys:
            res.append(data[k])
        return np.array(res)

    def _make_time_series_dataset(self, data):
        tensorDict = {}
        for i in self.config:
            process_data = self._dict_keys_values(
                data, self.config[i][&#39;colNames&#39;])
            tsf = Time_Series_Tensor_Factory(
                process_data,
                self.config[i][&#39;tensorType&#39;]
            )
            tensor = tsf.get_time_series_tensor(
                name=i,
                **self.config[i][&#39;param&#39;]
            )
            if self.config[i].get(&#39;sequence_stack&#39;) is not None:
                sequence_stack = self.config[i].get(&#39;sequence_stack&#39;)
                tensorDict[sequence_stack].stack_time_series_tensors(tensor)
            else:
                tensorDict[i] = tensor
        tensorList = [v for v in tensorDict.values()]
        return Time_Series_Dataset(tensorList).make_dataset()

    def make_data_generator(self):
        &#34;&#34;&#34;
        make_data_generator prepare an generator to output the transformed data
        
        
        Yields
        -------
        tuple
            it will output X data and Y data
        &#34;&#34;&#34;
        data = self.df.to_dict(&#39;records&#39;)
        for i in data:
            res = self._make_time_series_dataset(i)
            Xtensor = {}
            Ytensor = None
            for c in self.config:
                if self.config[c].get(&#34;sequence_stack&#34;) is not None:
                    continue
                if self.config[c].get(&#34;responseVariable&#34;):
                    Ytensor = res[&#39;data&#39;][c]
                else:
                    Xtensor[c] = res[&#39;data&#39;][c]
            yield (Xtensor, Ytensor)


    def expand_dataFrame_by_date(self, categoryCol,timeSeriesCol,newIX=True,byCategory=True,dropna=False):
        &#34;&#34;&#34;
        expand_dataFrame_by_date A help function to prepare dataFrame for tensor transformation
        
        It will change the original dataFrame of
        byCategory is set to be True [x1,x2,x3,time series,category] -&gt; [x1_t1,x1_t2...x3_t|index-&gt;category]
        byCategory is set to be False [x1,x2,x3,time series,category] -&gt; [category_x1_t1,category_x1_t2...category_x3_t]
        
        Note: 
        x is column name 
        t represent time series column i.e. Date --&gt; YYYY-MM-DD format is recommended
        
        Parameters
        ----------
        categoryCol : str
            column name of category
        timeSeriesCol : str
            column name of time series
        newIX : bool, optional
            if True, time series column will be converted into 1,2,3,....len(timeSeriesCol), by default True
        byCategory : bool, optional
            if True, the dataFrame will create new row instead of different column for categories, by default True
        dropna : bool, optional
            if True, nan column will be dropped, by default False
        
        Returns
        -------
        iterable
            the index of time series columns
        &#34;&#34;&#34;
        if newIX:
            self.df = self.df.sort_values(timeSeriesCol,ascending = True)
            ixDict = dict(zip(self.df[timeSeriesCol].unique(),list(range(1,len(self.df[timeSeriesCol].unique())+1))))
            self.df[timeSeriesCol] = self.df[timeSeriesCol].apply(lambda x: ixDict[x])
        else:
            ixDict = self.df[timeSeriesCol].values

        if byCategory:
            self.df = self._pivot_df(self.df,categoryCol,timeSeriesCol,dropna)
        else:
            self.df = self._flatten_df(self.df,categoryCol,timeSeriesCol,dropna)
        return ixDict

    def _pivot_df(self,df,categoryCol,timeSeriesCol,dropna):
        df = df.pivot(categoryCol,timeSeriesCol,df.columns.drop([categoryCol,timeSeriesCol]))
        df.columns = list(map(lambda x: f&#34;{x[0]}_{x[1]}&#34;,df.columns))
        if dropna:
            df = df.dropna(axis =1)
        return df

    def _flatten_df(self,df,categoryCol,timeSeriesCol,dropna):
        categoryList = df[categoryCol].unique()
        resDf = None
        for i in categoryList:
            subDf = df[df[categoryCol]==i]
            subDf = self._pivot_df(subDf,categoryCol,timeSeriesCol,dropna)
            subDf.columns = list(map(lambda x: f&#34;{i}_{x}&#34;,subDf.columns))
            subDf = subDf.reset_index(drop=True)
            if resDf is None:
                resDf = subDf
            else:
                resDf = pd.concat([resDf,subDf],axis =1)
        return resDf


    def transform_dataFrame(self,colName,targetCol,timeSeriesCol,transformFunc,*args,**kwargs):
        &#34;&#34;&#34;
        transform_dataFrame this function use apply method to transfrom dataFrame
        
        Parameters
        ----------
        colName : str
            target column for transformation
        targetCol : str
            the column to store new data
        timeSeriesCol : str
            time series column for sorting before apply function
        transformFunc : func
            the function implmented in the apply function
        axis : int, optional
            0 for row 1 for column, by default 1

        &#34;&#34;&#34;
        self.df = self.df.sort_values(timeSeriesCol,ascending = True)
        self.df[targetCol] = transformFunc(self.df[colName].values,*args,**kwargs)
        return self


    def __repr__(self):
        return f&#34;Tensor Transformer Config: {repr(self.config)}&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset.expand_dataFrame_by_date"><code class="name flex">
<span>def <span class="ident">expand_dataFrame_by_date</span></span>(<span>self, categoryCol, timeSeriesCol, newIX=True, byCategory=True, dropna=False)</span>
</code></dt>
<dd>
<div class="desc"><p>expand_dataFrame_by_date A help function to prepare dataFrame for tensor transformation</p>
<p>It will change the original dataFrame of
byCategory is set to be True [x1,x2,x3,time series,category] -&gt; [x1_t1,x1_t2&hellip;x3_t|index-&gt;category]
byCategory is set to be False [x1,x2,x3,time series,category] -&gt; [category_x1_t1,category_x1_t2&hellip;category_x3_t]</p>
<p>Note:
x is column name
t represent time series column i.e. Date &ndash;&gt; YYYY-MM-DD format is recommended</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>categoryCol</code></strong> :&ensp;<code>str</code></dt>
<dd>column name of category</dd>
<dt><strong><code>timeSeriesCol</code></strong> :&ensp;<code>str</code></dt>
<dd>column name of time series</dd>
<dt><strong><code>newIX</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, time series column will be converted into 1,2,3,....len(timeSeriesCol), by default True</dd>
<dt><strong><code>byCategory</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, the dataFrame will create new row instead of different column for categories, by default True</dd>
<dt><strong><code>dropna</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if True, nan column will be dropped, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>iterable</code></dt>
<dd>the index of time series columns</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand_dataFrame_by_date(self, categoryCol,timeSeriesCol,newIX=True,byCategory=True,dropna=False):
    &#34;&#34;&#34;
    expand_dataFrame_by_date A help function to prepare dataFrame for tensor transformation
    
    It will change the original dataFrame of
    byCategory is set to be True [x1,x2,x3,time series,category] -&gt; [x1_t1,x1_t2...x3_t|index-&gt;category]
    byCategory is set to be False [x1,x2,x3,time series,category] -&gt; [category_x1_t1,category_x1_t2...category_x3_t]
    
    Note: 
    x is column name 
    t represent time series column i.e. Date --&gt; YYYY-MM-DD format is recommended
    
    Parameters
    ----------
    categoryCol : str
        column name of category
    timeSeriesCol : str
        column name of time series
    newIX : bool, optional
        if True, time series column will be converted into 1,2,3,....len(timeSeriesCol), by default True
    byCategory : bool, optional
        if True, the dataFrame will create new row instead of different column for categories, by default True
    dropna : bool, optional
        if True, nan column will be dropped, by default False
    
    Returns
    -------
    iterable
        the index of time series columns
    &#34;&#34;&#34;
    if newIX:
        self.df = self.df.sort_values(timeSeriesCol,ascending = True)
        ixDict = dict(zip(self.df[timeSeriesCol].unique(),list(range(1,len(self.df[timeSeriesCol].unique())+1))))
        self.df[timeSeriesCol] = self.df[timeSeriesCol].apply(lambda x: ixDict[x])
    else:
        ixDict = self.df[timeSeriesCol].values

    if byCategory:
        self.df = self._pivot_df(self.df,categoryCol,timeSeriesCol,dropna)
    else:
        self.df = self._flatten_df(self.df,categoryCol,timeSeriesCol,dropna)
    return ixDict</code></pre>
</details>
</dd>
<dt id="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset.make_data_generator"><code class="name flex">
<span>def <span class="ident">make_data_generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>make_data_generator prepare an generator to output the transformed data</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>it will output X data and Y data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_data_generator(self):
    &#34;&#34;&#34;
    make_data_generator prepare an generator to output the transformed data
    
    
    Yields
    -------
    tuple
        it will output X data and Y data
    &#34;&#34;&#34;
    data = self.df.to_dict(&#39;records&#39;)
    for i in data:
        res = self._make_time_series_dataset(i)
        Xtensor = {}
        Ytensor = None
        for c in self.config:
            if self.config[c].get(&#34;sequence_stack&#34;) is not None:
                continue
            if self.config[c].get(&#34;responseVariable&#34;):
                Ytensor = res[&#39;data&#39;][c]
            else:
                Xtensor[c] = res[&#39;data&#39;][c]
        yield (Xtensor, Ytensor)</code></pre>
</details>
</dd>
<dt id="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset.set_config"><code class="name flex">
<span>def <span class="ident">set_config</span></span>(<span>self, name, colNames, tensorType, sequence_stack, isResponseVar, windowSize, seqSize, outType)</span>
</code></dt>
<dd>
<div class="desc"><p>set_config the setter of config</p>
<p>this setter provide an quick entry point to setup configuration</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the output sequence or output column</dd>
<dt><strong><code>colNames</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>the name of pandas frame used for transformation</dd>
<dt><strong><code>tensorType</code></strong> :&ensp;<code>{'sequence','label','category'}</code></dt>
<dd>provide different type of transformation</dd>
<dt><strong><code>sequence_stack</code></strong> :&ensp;<code>string</code> of <code>name for stacking</code></dt>
<dd>the target name for stacking</dd>
<dt><strong><code>isResponseVar</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether the data is response variable or predictor</dd>
<dt><strong><code>windowSize</code></strong> :&ensp;<code>int</code></dt>
<dd>sequence grouping size</dd>
<dt><strong><code>seqSize</code></strong> :&ensp;<code>int</code></dt>
<dd>total length of sequence</dd>
<dt><strong><code>outType</code></strong> :&ensp;<code>numpy data type</code></dt>
<dd>output data type</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_config(self, name, colNames, tensorType, sequence_stack, isResponseVar, windowSize, seqSize, outType):
    &#34;&#34;&#34;
    set_config the setter of config
    
    this setter provide an quick entry point to setup configuration
    
    Parameters
    ----------
    name : str
        the name of the output sequence or output column
    colNames : list of string
        the name of pandas frame used for transformation
    tensorType : {&#39;sequence&#39;,&#39;label&#39;,&#39;category&#39;}
        provide different type of transformation
    sequence_stack : string of name for stacking
        the target name for stacking
    isResponseVar : bool
        whether the data is response variable or predictor
    windowSize: int
        sequence grouping size
    seqSize: int
        total length of sequence
    outType: numpy data type
        output data type
    &#34;&#34;&#34;
    self.config[name] = {
        &#39;colNames&#39;: colNames,
        &#39;tensorType&#39;: tensorType,
        &#39;param&#39;: {
            &#34;windowSize&#34;: windowSize, 
            &#34;seqSize&#34;: seqSize, 
            &#34;outType&#34;: outType
            },
        &#39;sequence_stack&#39;: sequence_stack,
        &#39;responseVariable&#39;: isResponseVar
    }</code></pre>
</details>
</dd>
<dt id="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset.transform_dataFrame"><code class="name flex">
<span>def <span class="ident">transform_dataFrame</span></span>(<span>self, colName, targetCol, timeSeriesCol, transformFunc, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>transform_dataFrame this function use apply method to transfrom dataFrame</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>colName</code></strong> :&ensp;<code>str</code></dt>
<dd>target column for transformation</dd>
<dt><strong><code>targetCol</code></strong> :&ensp;<code>str</code></dt>
<dd>the column to store new data</dd>
<dt><strong><code>timeSeriesCol</code></strong> :&ensp;<code>str</code></dt>
<dd>time series column for sorting before apply function</dd>
<dt><strong><code>transformFunc</code></strong> :&ensp;<code>func</code></dt>
<dd>the function implmented in the apply function</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>0 for row 1 for column, by default 1</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_dataFrame(self,colName,targetCol,timeSeriesCol,transformFunc,*args,**kwargs):
    &#34;&#34;&#34;
    transform_dataFrame this function use apply method to transfrom dataFrame
    
    Parameters
    ----------
    colName : str
        target column for transformation
    targetCol : str
        the column to store new data
    timeSeriesCol : str
        time series column for sorting before apply function
    transformFunc : func
        the function implmented in the apply function
    axis : int, optional
        0 for row 1 for column, by default 1

    &#34;&#34;&#34;
    self.df = self.df.sort_values(timeSeriesCol,ascending = True)
    self.df[targetCol] = transformFunc(self.df[colName].values,*args,**kwargs)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="time_series_transform.transform_core_api" href="index.html">time_series_transform.transform_core_api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset" href="#time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset">Pandas_Time_Series_Panel_Dataset</a></code></h4>
<ul class="">
<li><code><a title="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset.expand_dataFrame_by_category" href="#time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset.expand_dataFrame_by_category">expand_dataFrame_by_category</a></code></li>
<li><code><a title="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset.make_lead_column" href="#time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset.make_lead_column">make_lead_column</a></code></li>
<li><code><a title="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset.make_slide_window" href="#time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset.make_slide_window">make_slide_window</a></code></li>
<li><code><a title="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset.transform_dataFrame" href="#time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Panel_Dataset.transform_dataFrame">transform_dataFrame</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset" href="#time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset">Pandas_Time_Series_Tensor_Dataset</a></code></h4>
<ul class="">
<li><code><a title="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset.expand_dataFrame_by_date" href="#time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset.expand_dataFrame_by_date">expand_dataFrame_by_date</a></code></li>
<li><code><a title="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset.make_data_generator" href="#time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset.make_data_generator">make_data_generator</a></code></li>
<li><code><a title="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset.set_config" href="#time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset.set_config">set_config</a></code></li>
<li><code><a title="time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset.transform_dataFrame" href="#time_series_transform.transform_core_api.time_series_transformer.Pandas_Time_Series_Tensor_Dataset.transform_dataFrame">transform_dataFrame</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>